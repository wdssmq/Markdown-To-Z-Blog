---
title: 「言说」2023 年仍然在纠结密码问题什么的
date: 2023-03-28 12:28:01
tags:
 - 说点什么
 - 言说
categories:
 - 电脑网络
id: 753
alias: 20230102708
---

## 前言

一直以来有一个纠结，正好在临开写前想到了如何概述这个纠结，那就是 ——

「实名过的小号还算不算小号这件事.jpg」

<!--more-->

## 过于安全的「安全问题」

中文翻译成「密保问题」可能更准确些，当年 QQ 也确实是这么叫的，后来慢慢以手机验证替代了，出过一个自己的 TOTP 验证工具，目测也已经被放弃了。

然后去年新买了台路由，就比较不理解也是要设置密保问题，按复位键后要回答问题才能实现重置，只能说大概率不会真的忘记登录密码。。吧。。

再然后是 Yandex 邮箱，没绑定手机，但是绑定了另一个邮箱，密保问题是「`«Your favorite childhood book»`」，答案是什么来着？？？

用一个兼具「语义属性」但仍然以「正确性」为主的文本内容，去保护另一个姑且只需要正确性的密码，这种设计就真的非常非常非常奇怪吧。。

「语义」让其有了「不需要特别去记」的迷惑性，「正确性」又实质上相当于把密码加长了一部分，浏览器还没办法自动帮我记忆……

就，，太安全了，，，安全到我自己都通不过验证。。

话说最近给 github 设置两步验证时有给一个恢复码的文件，其实还有一份谷歌的备用验证码是 2017 年生成的，文件一直还在，虽然 10 组密码只用了 1 组，，这些文件被弄丢的概率还是要比忘记「密保问题的答案」还是要低的。。

## 关于密码本身

密码本身可以借助工具自动记忆，另一方面大部分也都可以通过「找回密码」来重置，然而感觉很多用户包括我并不能在「忘记的后果」上和密保问题相区分，将同样的心态代入到了设置密保的步骤，也是密保问题不够科学的一个原因。

然后是密码文本的构成，其实，不考虑手动输入的话，随机生成是最安全的，然而现实并不理想……

「[花密 FlowerPassword](https://flowerpassword.com/ "花密 FlowerPassword")」 ← `2011-2023`，原来这东西已经这么久了么。。。

花密使用`「记忆密码」 + 「区分代号」`计算生成密码，然而我没使用它的一个原因是，企鹅的账号我该用 `Tencent` 还是 `QQ` 作为区分代号？？？

这是很认真的在纠结……然后刚才发现区分代代码还是分大小写的，，更纠结了。。 - -||

最后，生成后再复制使用仍然是不方便……

## 我自己的密码方案

最早试过直接在密码最后用 `QQ` `GG` `FF` 这种后缀，后来试过年月汉字的五笔编码，然而一到十对应的首字母只有 8 个，就想到像 TOTP 那样用时间周期来生成，周期以天为基础单位，输出长度开始是 3 位，后来改成了 4 位，作为后缀附加到固定密码后面。

最早也不是用自动生成的时间周期，而是 win10 官方标题里提取，`202X 年 XX 月更新`这种；「- 现在改成了 `22H2` 的格式 -」

虽然结果就是在同一周期内设置或重置的密码会变成一样的…… - -||

回到开头的那个纠结上，一些小号使用的密码，其固定组成的部分中的数字部分会用一串比较好输入的构成，正式的则用另一串……

所以「实名过的小号」我该用哪边的密码？？？ - -||

## 所以代码呢

Web 版：

> GenCode - 一个特殊的 TOTP 生成工具 - 我的网站：
>
> [https://demo.wdssmq.com/tools/GenCode/](https://demo.wdssmq.com/tools/GenCode/ "GenCode - 一个特殊的 TOTP 生成工具 - 我的网站")

↑ 用了小程序的代码重写过的，然后，并没有用 taro 直接生成网页版，样式啥的都要调整；

小程序，用的 taro：

> taro-prime-ts · 沉冰浮水/水水的旧代码合集 - 码云 - 开源中国：
>
> [https://gitee.com/wdssmq/StaleCode/tree/master/taro-prime-ts](https://gitee.com/wdssmq/StaleCode/tree/master/taro-prime-ts "taro-prime-ts · 沉冰浮水/水水的旧代码合集 - 码云 - 开源中国")

↑ 好像这个才是第一个用 ts 的项目，前几天开新坑时给并没有想起来，，还以为那边才是第一次.jpg

↑ 需要加个 README.md 贴个小程序码，以及是不是把核心部分再抽离个 lib 出来，，然后实际上架的微信小程序也用的原生写法 - -||

## 关于「算法」

好像有条`「不要自己发明加密算法」`的古训来着，，可是只输出 4 位的话用复杂的加密又感觉很浪费。。

上边实现用的代码是自己糊的，感觉最大的问题是自己会想要修改……

姑且也用 AI 生成了下，，以下是用的咒语和大概看起来不错的结果，虽然实际运行后感觉不太行。。

> 不用复杂的加密实现一个基于时间的 hash 算法，密钥只有数字，时间周期为 n 天，同一周期内输出相同的结果，只有基本的加减剩除、进制转换以及 charCodeAt，输出为 4 位纯字母，A-Z 都有可能出现

----

好的，我可以为您提供一个简单的基于时间的哈希算法。以下是算法的步骤：

1.获取当前时间并将其转换为自 1970-01-01 以来的秒数。

2.将密钥转换为数字，并将它们相加。

3.将第一步中得到的秒数除以 n 天的秒数（即 24 小时 60 分钟 60 秒 * n）并取整数部分。

4.将第二步中得到的数字加上第三步中得到的整数。

5.将结果转换为 26 进制，然后将每个数字与'A'相加，获得相应的字母。

6.将这四个字母连接起来，得到最终结果。

以下是实现该算法的 JavaScript 代码片段：

```js
function getTimeBasedHash(key, n) {
  const now = Math.round(Date.now() / 1000);
  const keyNum = parseInt(key);
  const daySeconds = 24 * 60 * 60 * n;
  let hashNum = Math.floor(now / daySeconds) + keyNum;
  let hashStr = "";
  while (hashNum > 0) {
    const remainder = hashNum % 26;
    const charCode = remainder + 65;
    hashStr = String.fromCharCode(charCode) + hashStr;
    hashNum = Math.floor(hashNum / 26);
  }
  return hashStr.padStart(4, "A");
}

```
请注意，此函数需要两个参数：密钥和时间周期（以天为单位）。它将返回一个由四个大写字母组成的字符串作为哈希结果。同一时间周期内，相同的密钥将始终生成相同的哈希值。

----

## 大概是以上内容的总结

1、日常使用两组密码，其中一组中的数字部分相对比较简单，给一些小号使用，然而「实名过的小号还算不算小号.jpg」，该用哪组密码呢？

2、吐槽了使用「密保问题」来重置密码的方案，太安全了，我自己都过不了；

3、对于密码本身，不需要考虑手动输入时，「随机生成 + 密码管理器」就好；

4、上一条终究不那么理想，所以我的选择是，在固定密码组成的基础上，额外附加几位随时间周期变化的后缀，多输几次总会记住，在那之前可以重新生成；

5、所以如何「选定」一个生成算法呢？虽然目前自己糊了个。。「不要自己发明算法.jpg」

## 其他

话说 QQ 的手机版「QQ 安全中心」已经实质性下线了？

各种验证都基本上只有手机号或扫码了，那个动态口令已经很久没用过了……

然后，登录历史只到「2022-06-16」，今天是「2023-03-28」……

「已经连续守护您 1035 天.jpg」。。。要不要卸载掉。。。
